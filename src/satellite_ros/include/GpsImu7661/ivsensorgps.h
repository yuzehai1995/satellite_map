// Generated by gencpp from file GpsImu7661/ivsensorgps.msg
// DO NOT EDIT!


#ifndef GPSIMU7661_MESSAGE_IVSENSORGPS_H
#define GPSIMU7661_MESSAGE_IVSENSORGPS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace GpsImu7661
{
template <class ContainerAllocator>
struct ivsensorgps_
{
  typedef ivsensorgps_<ContainerAllocator> Type;

  ivsensorgps_()
    : header()
    , lon(0.0)
    , lat(0.0)
    , height(0.0)
    , mode(0)
    , heading(0.0)
    , velocity(0.0)
    , status(0)
    , satenum(0)
    , isvalid(0)
    , acceleration(0.0)
    , pitch(0.0)
    , roll(0.0)
    , angx(0.0)
    , angy(0.0)
    , yaw(0.0)
    , accx(0.0)
    , accy(0.0)
    , accz(0.0)
    , msgflag()  {
    }
  ivsensorgps_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , lon(0.0)
    , lat(0.0)
    , height(0.0)
    , mode(0)
    , heading(0.0)
    , velocity(0.0)
    , status(0)
    , satenum(0)
    , isvalid(0)
    , acceleration(0.0)
    , pitch(0.0)
    , roll(0.0)
    , angx(0.0)
    , angy(0.0)
    , yaw(0.0)
    , accx(0.0)
    , accy(0.0)
    , accz(0.0)
    , msgflag(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef double _lon_type;
  _lon_type lon;

   typedef double _lat_type;
  _lat_type lat;

   typedef double _height_type;
  _height_type height;

   typedef uint8_t _mode_type;
  _mode_type mode;

   typedef double _heading_type;
  _heading_type heading;

   typedef double _velocity_type;
  _velocity_type velocity;

   typedef uint8_t _status_type;
  _status_type status;

   typedef int32_t _satenum_type;
  _satenum_type satenum;

   typedef uint8_t _isvalid_type;
  _isvalid_type isvalid;

   typedef double _acceleration_type;
  _acceleration_type acceleration;

   typedef double _pitch_type;
  _pitch_type pitch;

   typedef double _roll_type;
  _roll_type roll;

   typedef double _angx_type;
  _angx_type angx;

   typedef double _angy_type;
  _angy_type angy;

   typedef double _yaw_type;
  _yaw_type yaw;

   typedef double _accx_type;
  _accx_type accx;

   typedef double _accy_type;
  _accy_type accy;

   typedef double _accz_type;
  _accz_type accz;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _msgflag_type;
  _msgflag_type msgflag;





  typedef boost::shared_ptr< ::GpsImu7661::ivsensorgps_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::GpsImu7661::ivsensorgps_<ContainerAllocator> const> ConstPtr;

}; // struct ivsensorgps_

typedef ::GpsImu7661::ivsensorgps_<std::allocator<void> > ivsensorgps;

typedef boost::shared_ptr< ::GpsImu7661::ivsensorgps > ivsensorgpsPtr;
typedef boost::shared_ptr< ::GpsImu7661::ivsensorgps const> ivsensorgpsConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::GpsImu7661::ivsensorgps_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::GpsImu7661::ivsensorgps_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace GpsImu7661

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'GpsImu7661': ['/home/fish/catkin_velodyne_1604_05028_GPS/src/GpsImu7661/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::GpsImu7661::ivsensorgps_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::GpsImu7661::ivsensorgps_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::GpsImu7661::ivsensorgps_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::GpsImu7661::ivsensorgps_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::GpsImu7661::ivsensorgps_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::GpsImu7661::ivsensorgps_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::GpsImu7661::ivsensorgps_<ContainerAllocator> >
{
  static const char* value()
  {
    return "c5103a551237f2269c493e1c29c65fa8";
  }

  static const char* value(const ::GpsImu7661::ivsensorgps_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xc5103a551237f226ULL;
  static const uint64_t static_value2 = 0x9c493e1c29c65fa8ULL;
};

template<class ContainerAllocator>
struct DataType< ::GpsImu7661::ivsensorgps_<ContainerAllocator> >
{
  static const char* value()
  {
    return "GpsImu7661/ivsensorgps";
  }

  static const char* value(const ::GpsImu7661::ivsensorgps_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::GpsImu7661::ivsensorgps_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n\
float64 lon\n\
float64 lat\n\
float64 height\n\
uint8 mode\n\
float64 heading\n\
float64 velocity\n\
uint8 status\n\
int32 satenum\n\
uint8 isvalid\n\
float64 acceleration\n\
float64 pitch\n\
float64 roll\n\
float64 angx\n\
float64 angy\n\
float64 yaw\n\
float64 accx\n\
float64 accy\n\
float64 accz\n\
string msgflag\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::GpsImu7661::ivsensorgps_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::GpsImu7661::ivsensorgps_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.lon);
      stream.next(m.lat);
      stream.next(m.height);
      stream.next(m.mode);
      stream.next(m.heading);
      stream.next(m.velocity);
      stream.next(m.status);
      stream.next(m.satenum);
      stream.next(m.isvalid);
      stream.next(m.acceleration);
      stream.next(m.pitch);
      stream.next(m.roll);
      stream.next(m.angx);
      stream.next(m.angy);
      stream.next(m.yaw);
      stream.next(m.accx);
      stream.next(m.accy);
      stream.next(m.accz);
      stream.next(m.msgflag);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ivsensorgps_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::GpsImu7661::ivsensorgps_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::GpsImu7661::ivsensorgps_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "lon: ";
    Printer<double>::stream(s, indent + "  ", v.lon);
    s << indent << "lat: ";
    Printer<double>::stream(s, indent + "  ", v.lat);
    s << indent << "height: ";
    Printer<double>::stream(s, indent + "  ", v.height);
    s << indent << "mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.mode);
    s << indent << "heading: ";
    Printer<double>::stream(s, indent + "  ", v.heading);
    s << indent << "velocity: ";
    Printer<double>::stream(s, indent + "  ", v.velocity);
    s << indent << "status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.status);
    s << indent << "satenum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.satenum);
    s << indent << "isvalid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.isvalid);
    s << indent << "acceleration: ";
    Printer<double>::stream(s, indent + "  ", v.acceleration);
    s << indent << "pitch: ";
    Printer<double>::stream(s, indent + "  ", v.pitch);
    s << indent << "roll: ";
    Printer<double>::stream(s, indent + "  ", v.roll);
    s << indent << "angx: ";
    Printer<double>::stream(s, indent + "  ", v.angx);
    s << indent << "angy: ";
    Printer<double>::stream(s, indent + "  ", v.angy);
    s << indent << "yaw: ";
    Printer<double>::stream(s, indent + "  ", v.yaw);
    s << indent << "accx: ";
    Printer<double>::stream(s, indent + "  ", v.accx);
    s << indent << "accy: ";
    Printer<double>::stream(s, indent + "  ", v.accy);
    s << indent << "accz: ";
    Printer<double>::stream(s, indent + "  ", v.accz);
    s << indent << "msgflag: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.msgflag);
  }
};

} // namespace message_operations
} // namespace ros

#endif // GPSIMU7661_MESSAGE_IVSENSORGPS_H
